class TaskHistory < ActiveRecord::Base
  belongs_to :task
  belongs_to :milestone
  belongs_to :task_category
  belongs_to :task_status

  # Prevent edit / update of history record.  Supposed to be audit trail of changes.
  def validate_on_update
    errors.add_to_base( "Can not update #{self.class.to_s} instance")
  end

  validate do |history|
    # In each of the 'unless' conditions, true means that the association is reloaded,
    # if it does not exist, nil is returned
    #
    # Can not use following validation test if want to be able to use
    #   inst.task_histories << TaskHistory.new( self )
    #   inst.save
    # or variations.  The task_history.task_id has not been filled in yet when the
    # validation is [first] run (at least when also creating the Task instance).
    #unless history.task( true )
    #  history.errors.add :task_id, 'does not exist'
    #end
  end
  
  # Make sure a few attributes can not be filled in [directly] using the standard 'list'
  # generated by web forms.
  attr_protected :task_id, :milestone_id, :created_at

  def to_label
    "#{created_at}"
  end

  # Customize the initialize to pull attribute values from the parent / owner
  # Task instance.  This also makes the task instance a required parameter for the
  # .new method.
  alias :standard_initialize :initialize
  def initialize( task )
    #raise ArgumentError, "need a Task, not a '#{task.class}'" if not Task.is_a_task?( task )
    raise ArgumentError, "need a Task, not a '#{task.class}'" if not task.is_a?( Task )
    self.standard_initialize({
      :title              => task.title,
      :task_category_id   => task.task_category_id,
      :task_status_id     => task.task_status_id,
      :description        => task.description,
      :start_date         => task.start_date,
      :end_date           => task.end_date,
      :etc_date           => task.etc_date
    })
    self.milestone_id     = task.milestone_id
    self.task_id          = task.id
    self
  end #initialize( task, specified = {})

  # Prevent edit / update of history record.  Supposed to be audit trail of changes.
  def update
    errors.add_to_base( "Update #{self.class.to_s} instance rejected")
    return false
  end

  # Would really like to override the save methods to require a Task instance argument,
  # but that would break (with current knowledge) using things like
  #   inst.task_histories << TaskHistory.new( self )
  #   inst.save
  # where the TaskHistory save method is automatically called, without the chance to
  # specify any arguments.
  # hpd Is there a way to prevent save from working **unless** call in a Task instance
  # context?
  # HPD how about checking for #new_record? fail unless is new instance?
  def save
    if not @new_record
      errors.add_to_base( "Update #{self.class.to_s} instance rejected")
      #raise "prevent save: #{self.inspect}"
      return false
    end
    super
  end #save
  def save!
    save || raise( RecordNotSaved )
  end
  
  # Override find to add functionality to test for / trap errors unknown and invalid
  # ids
  # HPD still raw copy of code from :base
#  def find(*args)
#    options = extract_options_from_args!(args)
#    validate_find_options(options)
#    set_readonly_option!(options)
#
#    case args.first
#      when :first then find_initial(options)
#      when :all   then find_every(options)
#      else             find_from_ids(args, options)
#    end
#  end
  def find_one(id, options)
    conditions = " AND (#{sanitize_sql(options[:conditions])})" if options[:conditions]
    options.update :conditions => "#{table_name}.#{primary_key} = #{quote_value(id,columns_hash[primary_key])}#{conditions}"

    # Use find_every(options).first since the primary key condition
    # already ensures we have a single record. Using find_initial adds
    # a superfluous :limit => 1.
    if result = find_every(options).first
      result
    else
      #hpd instead of raising error, add message to model errors
      #hpd issue with return / result value?
      #hpd alternate messages if id [not]numeric
      #errors.add_to_base( "" )
      #hpd better place than base? force re
      raise RecordNotFound, "Couldn't find #{name} with ID=#{id}#{conditions}"
    end
  end
end