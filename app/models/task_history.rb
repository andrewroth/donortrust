class TaskHistory < ActiveRecord::Base
  belongs_to :task
  belongs_to :milestone
  belongs_to :task_category
  belongs_to :task_status

  # Prevent edit / update of history record.  Supposed to be audit trail of changes.
  def validate_on_update
    errors.add_to_base( "Can not update #{self.class.to_s} instance")
  end

  validate do |history|
    # In each of the 'unless' conditions, true means that the association is reloaded,
    # if it does not exist, nil is returned
    #
    # Can not use following validation test if want to be able to use
    #   inst.task_histories << TaskHistory.new( self )
    #   inst.save
    # or variations.  The task_history.task_id has not been filled in yet when the
    # validation is [first] run (at least when also creating the Task instance).
    #unless history.task( true )
    #  history.errors.add :task_id, 'does not exist'
    #end
  end
  
  # Make sure a few attributes can not be filled in [directly] using the standard 'list'
  # generated by web forms.
  attr_protected :task_id, :milestone_id, :created_at

  # Customize the initialize to pull attribute values from the parent / owner
  # Task instance.  This also makes the task instance a required parameter for the
  # .new method.
  alias :standard_initialize :initialize
  def initialize( task )
    #raise ArgumentError, "need a Task, not a '#{task.class}'" if not Task.is_a_task?( task )
    raise ArgumentError, "need a Task, not a '#{task.class}'" if not task.is_a?( Task )
    self.standard_initialize({
      :title              => task.title,
      :task_category_id   => task.task_category_id,
      :task_status_id     => task.task_status_id,
      :description        => task.description,
      :start_date         => task.start_date,
      :end_date           => task.end_date,
      :etc_date           => task.etc_date
    })
    self.milestone_id     = task.milestone_id
    self.task_id          = task.id
    self
  end #initialize( task, specified = {})

  # Prevent edit / update of history record.  Supposed to be audit trail of changes.
  def update
    errors.add_to_base( "Update #{self.class.to_s} instance rejected")
    return false
  end

  # Would really like to override the save methods to require a Task instance argument,
  # but that would break (with current knowledge) using things like
  #   inst.task_histories << TaskHistory.new( self )
  #   inst.save
  # where the TaskHistory save method is automatically called, without the chance to
  # specify any arguments.
  # hpd Is there a way to prevent save from working **unless** call in a Task instance
  # context?
  #def save
  #  # code similar to that used in initialize method above
  #  super
  #end #save
end